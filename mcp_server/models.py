# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T17:05:09+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional

from pydantic import BaseModel, Field


class OpTypes(Enum):
    heartbeat = 'heartbeat'
    authentication = 'authentication'
    marketSubscription = 'marketSubscription'
    orderSubscription = 'orderSubscription'


class OpTypes1(Enum):
    connection = 'connection'
    status = 'status'
    mcm = 'mcm'
    ocm = 'ocm'


class KeyLineSelection(BaseModel):
    hc: Optional[float] = None
    id: Optional[int] = None


class Ct(Enum):
    SUB_IMAGE = 'SUB_IMAGE'
    RESUB_DELTA = 'RESUB_DELTA'
    HEARTBEAT = 'HEARTBEAT'


class SegmentType(Enum):
    SEG_START = 'SEG_START'
    SEG = 'SEG'
    SEG_END = 'SEG_END'


class FieldModel(Enum):
    EX_BEST_OFFERS_DISP = 'EX_BEST_OFFERS_DISP'
    EX_BEST_OFFERS = 'EX_BEST_OFFERS'
    EX_ALL_OFFERS = 'EX_ALL_OFFERS'
    EX_TRADED = 'EX_TRADED'
    EX_TRADED_VOL = 'EX_TRADED_VOL'
    EX_LTP = 'EX_LTP'
    EX_MARKET_DEF = 'EX_MARKET_DEF'
    SP_TRADED = 'SP_TRADED'
    SP_PROJECTED = 'SP_PROJECTED'


class MarketDataFilter(BaseModel):
    fields: Optional[List[FieldModel]] = None
    ladderLevels: Optional[int] = None


class BettingType(Enum):
    ODDS = 'ODDS'
    LINE = 'LINE'
    RANGE = 'RANGE'
    ASIAN_HANDICAP_DOUBLE_LINE = 'ASIAN_HANDICAP_DOUBLE_LINE'
    ASIAN_HANDICAP_SINGLE_LINE = 'ASIAN_HANDICAP_SINGLE_LINE'


class Status(Enum):
    INACTIVE = 'INACTIVE'
    OPEN = 'OPEN'
    SUSPENDED = 'SUSPENDED'
    CLOSED = 'CLOSED'


class MarketFilter(BaseModel):
    bettingTypes: Optional[List[BettingType]] = None
    bspMarket: Optional[bool] = None
    countryCodes: Optional[List[str]] = None
    eventIds: Optional[List[str]] = None
    eventTypeIds: Optional[List[str]] = None
    marketIds: Optional[List[str]] = None
    marketTypes: Optional[List[str]] = None
    raceTypes: Optional[List[str]] = None
    turnInPlayEnabled: Optional[bool] = None
    venues: Optional[List[str]] = None


class Ot(Enum):
    L = 'L'
    LOC = 'LOC'
    MOC = 'MOC'


class Pt(Enum):
    L = 'L'
    P = 'P'
    MOC = 'MOC'


class Side(Enum):
    B = 'B'
    L = 'L'


class Status1(Enum):
    E = 'E'
    EC = 'EC'


class Order(BaseModel):
    avp: Optional[float] = Field(
        None,
        description='Average Price Matched - the average price the order was matched at (null if the order is not matched). This value is not meaningful for activity on Line markets and is not guaranteed to be returned or maintained for\xa0these markets.',
    )
    bsp: Optional[float] = Field(
        None,
        description='BSP Liability - the BSP liability of the order (null if the order is not a BSP order)',
    )
    cd: Optional[int] = Field(
        None,
        description='Cancelled Date - the date the order was cancelled (null if the order is not cancelled)',
    )
    id: Optional[str] = Field(None, description='Bet Id - the id of the order')
    ld: Optional[int] = Field(
        None,
        description='Lapsed Date - the date the order was lapsed (null if the order is not lapsed)',
    )
    lsrc: Optional[str] = Field(
        None,
        description='Lapse Status Reason Code - the reason that some or all of this order has been lapsed (null if no portion of the order is lapsed',
    )
    md: Optional[int] = Field(
        None,
        description='Matched Date - the date the order was matched (null if the order is not matched)',
    )
    ot: Optional[Ot] = Field(
        None,
        description='Order Type - the type of the order (L = LIMIT, MOC = MARKET_ON_CLOSE, LOC = LIMIT_ON_CLOSE)',
    )
    p: Optional[float] = Field(
        None,
        description='Price - the original placed price of the order. Line markets operate at even-money odds of 2.0.\xa0However, price for these markets refers to the line positions available as defined by the markets min-max range and interval steps',
    )
    pd: Optional[int] = Field(
        None, description='Placed Date - the date the order was placed'
    )
    pt: Optional[Pt] = Field(
        None,
        description='Persistence Type - whether the order will persist at in play or not (L = LAPSE, P = PERSIST, MOC = Market On Close)',
    )
    rac: Optional[str] = Field(
        None,
        description='Regulator Auth Code - the auth code returned by the regulator',
    )
    rc: Optional[str] = Field(
        None, description='Regulator Code - the regulator of the order'
    )
    rfo: Optional[str] = Field(
        None,
        description="Order Reference - the customer's order reference for this order (empty string if one was not set)",
    )
    rfs: Optional[str] = Field(
        None,
        description="Strategy Reference - the customer's strategy reference for this order (empty string if one was not set)",
    )
    s: Optional[float] = Field(
        None, description='Size - the original placed size of the order'
    )
    sc: Optional[float] = Field(
        None,
        description='Size Cancelled - the amount of the order that has been cancelled',
    )
    side: Optional[Side] = Field(
        None,
        description="Side - the side of the order. For Line markets a 'B' bet refers to a SELL line and an 'L' bet refers\xa0to a BUY line.",
    )
    sl: Optional[float] = Field(
        None, description='Size Lapsed - the amount of the order that has been lapsed'
    )
    sm: Optional[float] = Field(
        None, description='Size Matched - the amount of the order that has been matched'
    )
    sr: Optional[float] = Field(
        None,
        description='Size Remaining - the amount of the order that is remaining unmatched',
    )
    status: Optional[Status1] = Field(
        None,
        description='Status - the status of the order (E = EXECUTABLE, EC = EXECUTION_COMPLETE)',
    )
    sv: Optional[float] = Field(
        None, description='Size Voided - the amount of the order that has been voided'
    )


class OrderFilter(BaseModel):
    accountIds: Optional[List[int]] = Field(
        None,
        description='Internal use only & should not be set on your filter (your subscription is already locked to your account). If set subscription will fail.',
    )
    customerStrategyRefs: Optional[List[str]] = Field(
        None,
        description='Restricts to specified customerStrategyRefs; this will filter orders and StrategyMatchChanges accordingly (Note: overall postition is not filtered)',
    )
    includeOverallPosition: Optional[bool] = Field(
        None,
        description='Returns overall / net position (See: OrderRunnerChange.mb / OrderRunnerChange.ml). Default=true',
    )
    partitionMatchedByStrategyRef: Optional[bool] = Field(
        None,
        description='Returns strategy positions (See: OrderRunnerChange.smc=Map<customerStrategyRef, StrategyMatchChange>) - these are sent in delta format as per overall position. Default=false',
    )


class Type(Enum):
    CLASSIC = 'CLASSIC'
    FINEST = 'FINEST'
    LINE_RANGE = 'LINE_RANGE'


class PriceLadderDefinition(BaseModel):
    type: Optional[Type] = None


class RequestMessage(BaseModel):
    id: Optional[int] = Field(
        None,
        description='Client generated unique id to link request with response (like json rpc)',
    )
    op: Optional[str] = Field(None, description='The operation type')


class ResponseMessage(BaseModel):
    id: Optional[int] = Field(
        None,
        description='Client generated unique id to link request with response (like json rpc)',
    )
    op: Optional[str] = Field(None, description='The operation type')


class RunnerChange(BaseModel):
    atb: Optional[List[List[float]]] = Field(
        None,
        description='Available To Back - PriceVol tuple delta of price changes (0 vol is remove)',
    )
    atl: Optional[List[List[float]]] = Field(
        None,
        description='Available To Lay - PriceVol tuple delta of price changes (0 vol is remove)',
    )
    batb: Optional[List[List[float]]] = Field(
        None,
        description='Best Available To Back - LevelPriceVol triple delta of price changes, keyed by level (0 vol is remove)',
    )
    batl: Optional[List[List[float]]] = Field(
        None,
        description='Best Available To Lay - LevelPriceVol triple delta of price changes, keyed by level (0 vol is remove)',
    )
    bdatb: Optional[List[List[float]]] = Field(
        None,
        description='Best Display Available To Back (includes virtual prices)- LevelPriceVol triple delta of price changes, keyed by level (0 vol is remove)',
    )
    bdatl: Optional[List[List[float]]] = Field(
        None,
        description='Best Display Available To Lay (includes virtual prices)- LevelPriceVol triple delta of price changes, keyed by level (0 vol is remove)',
    )
    hc: Optional[float] = Field(
        None,
        description='Handicap - the handicap of the runner (selection) (null if not applicable)',
    )
    id: Optional[int] = Field(
        None, description='Selection Id - the id of the runner (selection)'
    )
    ltp: Optional[float] = Field(
        None,
        description='Last Traded Price - The last traded price (or null if un-changed)',
    )
    spb: Optional[List[List[float]]] = Field(
        None,
        description='Starting Price Back - PriceVol tuple delta of price changes (0 vol is remove)',
    )
    spf: Optional[float] = Field(
        None,
        description='Starting Price Far - The far starting price (or null if un-changed)',
    )
    spl: Optional[List[List[float]]] = Field(
        None,
        description='Starting Price Lay - PriceVol tuple delta of price changes (0 vol is remove)',
    )
    spn: Optional[float] = Field(
        None,
        description='Starting Price Near - The far starting price (or null if un-changed)',
    )
    trd: Optional[List[List[float]]] = Field(
        None,
        description='Traded - PriceVol tuple delta of price changes (0 vol is remove)',
    )
    tv: Optional[float] = Field(
        None, description='The total amount matched. This value is truncated at 2dp.'
    )


class Status2(Enum):
    ACTIVE = 'ACTIVE'
    WINNER = 'WINNER'
    LOSER = 'LOSER'
    REMOVED = 'REMOVED'
    REMOVED_VACANT = 'REMOVED_VACANT'
    HIDDEN = 'HIDDEN'
    PLACED = 'PLACED'


class RunnerDefinition(BaseModel):
    adjustmentFactor: Optional[float] = None
    bsp: Optional[float] = None
    hc: Optional[float] = Field(
        None,
        description='Handicap - the handicap of the runner (selection) (null if not applicable)',
    )
    id: Optional[int] = Field(
        None, description='Selection Id - the id of the runner (selection)'
    )
    removalDate: Optional[datetime] = None
    sortPriority: Optional[int] = None
    status: Optional[Status2] = None


class ErrorCode(Enum):
    NO_APP_KEY = 'NO_APP_KEY'
    INVALID_APP_KEY = 'INVALID_APP_KEY'
    NO_SESSION = 'NO_SESSION'
    INVALID_SESSION_INFORMATION = 'INVALID_SESSION_INFORMATION'
    NOT_AUTHORIZED = 'NOT_AUTHORIZED'
    INVALID_INPUT = 'INVALID_INPUT'
    INVALID_CLOCK = 'INVALID_CLOCK'
    UNEXPECTED_ERROR = 'UNEXPECTED_ERROR'
    TIMEOUT = 'TIMEOUT'
    SUBSCRIPTION_LIMIT_EXCEEDED = 'SUBSCRIPTION_LIMIT_EXCEEDED'
    INVALID_REQUEST = 'INVALID_REQUEST'
    CONNECTION_FAILED = 'CONNECTION_FAILED'
    MAX_CONNECTION_LIMIT_EXCEEDED = 'MAX_CONNECTION_LIMIT_EXCEEDED'
    TOO_MANY_REQUESTS = 'TOO_MANY_REQUESTS'


class StatusCode(Enum):
    SUCCESS = 'SUCCESS'
    FAILURE = 'FAILURE'


class StatusMessage(ResponseMessage):
    connectionClosed: Optional[bool] = Field(
        None, description='Is the connection now closed'
    )
    connectionId: Optional[str] = Field(None, description='The connection id')
    connectionsAvailable: Optional[int] = Field(
        None,
        description='The number of connections available for this account at this moment in time. Present on responses to Authentication messages only.',
    )
    errorCode: Optional[ErrorCode] = Field(
        None, description='The type of error in case of a failure'
    )
    errorMessage: Optional[str] = Field(
        None, description='Additional message in case of a failure'
    )
    statusCode: Optional[StatusCode] = Field(
        None, description='The status of the last request'
    )


class StrategyMatchChange(BaseModel):
    mb: Optional[List[List[float]]] = Field(
        None,
        description='Matched Backs - matched amounts by distinct matched price on the Back side for this strategy',
    )
    ml: Optional[List[List[float]]] = Field(
        None,
        description='Matched Lays - matched amounts by distinct matched price on the Lay side for this strategy',
    )


class AuthenticationMessage(RequestMessage):
    appKey: Optional[str] = None
    session: Optional[str] = None


class ConnectionMessage(ResponseMessage):
    connectionId: Optional[str] = Field(None, description='The connection id')


HeartbeatMessage = RequestMessage


class KeyLineDefinition(BaseModel):
    kl: Optional[List[KeyLineSelection]] = None


class MarketDefinition(BaseModel):
    betDelay: Optional[int] = None
    bettingType: Optional[BettingType] = None
    bspMarket: Optional[bool] = None
    bspReconciled: Optional[bool] = None
    complete: Optional[bool] = None
    countryCode: Optional[str] = None
    crossMatching: Optional[bool] = None
    discountAllowed: Optional[bool] = None
    eachWayDivisor: Optional[float] = None
    eventId: Optional[str] = None
    eventTypeId: Optional[str] = Field(
        None, description='The Event Type the market is contained within.'
    )
    inPlay: Optional[bool] = None
    keyLineDefinition: Optional[KeyLineDefinition] = None
    lineInterval: Optional[float] = Field(
        None,
        description='For Handicap and Line markets, the lines available on this market will be between the range of lineMinUnit and lineMaxUnit, in increments of the lineInterval value. e.g. If unit is runs, lineMinUnit=10, lineMaxUnit=20 and lineInterval=0.5, then valid lines include 10, 10.5, 11, 11.5 up to 20 runs.',
    )
    lineMaxUnit: Optional[float] = Field(
        None,
        description='For Handicap and Line markets, the maximum value for the outcome, in market units for this market (eg 100 runs).',
    )
    lineMinUnit: Optional[float] = Field(
        None,
        description='For Handicap and Line markets, the minimum value for the outcome, in market units for this market (eg 0 runs).',
    )
    marketBaseRate: Optional[float] = None
    marketTime: Optional[datetime] = None
    marketType: Optional[str] = None
    numberOfActiveRunners: Optional[int] = None
    numberOfWinners: Optional[int] = None
    openDate: Optional[datetime] = None
    persistenceEnabled: Optional[bool] = None
    priceLadderDefinition: Optional[PriceLadderDefinition] = None
    raceType: Optional[str] = None
    regulators: Optional[List[str]] = Field(None, description='The market regulators.')
    runners: Optional[List[RunnerDefinition]] = None
    runnersVoidable: Optional[bool] = None
    settledTime: Optional[datetime] = None
    status: Optional[Status] = None
    suspendTime: Optional[datetime] = None
    timezone: Optional[str] = None
    turnInPlayEnabled: Optional[bool] = None
    venue: Optional[str] = None
    version: Optional[int] = None


class MarketSubscriptionMessage(RequestMessage):
    clk: Optional[str] = Field(
        None,
        description='Token value delta (received in MarketChangeMessage) that should be passed to resume a subscription',
    )
    conflateMs: Optional[int] = Field(
        None,
        description='Conflate Milliseconds - the conflation rate (looped back on initial image after validation: bounds are 0 to 120000)',
    )
    heartbeatMs: Optional[int] = Field(
        None,
        description='Heartbeat Milliseconds - the heartbeat rate (looped back on initial image after validation: bounds are 500 to 5000)',
    )
    initialClk: Optional[str] = Field(
        None,
        description='Token value (received in initial MarketChangeMessage) that should be passed to resume a subscription',
    )
    marketDataFilter: Optional[MarketDataFilter] = None
    marketFilter: Optional[MarketFilter] = None
    segmentationEnabled: Optional[bool] = Field(
        None,
        description='Segmentation Enabled - allow the server to send large sets of data in segments, instead of a single block',
    )


class OrderRunnerChange(BaseModel):
    fullImage: Optional[bool] = None
    hc: Optional[float] = Field(
        None,
        description='Handicap - the handicap of the runner (selection) (null if not applicable)',
    )
    id: Optional[int] = Field(
        None, description='Selection Id - the id of the runner (selection)'
    )
    mb: Optional[List[List[float]]] = Field(
        None,
        description='Matched Backs - matched amounts by distinct matched price on the Back side for this runner (selection)',
    )
    ml: Optional[List[List[float]]] = Field(
        None,
        description='Matched Lays - matched amounts by distinct matched price on the Lay side for this runner (selection)',
    )
    smc: Optional[Dict[str, StrategyMatchChange]] = Field(
        None,
        description='Strategy Matches - Matched Backs and Matched Lays grouped by strategy reference',
    )
    uo: Optional[List[Order]] = Field(
        None,
        description='Unmatched Orders - orders on this runner (selection) that are not fully matched',
    )


class OrderSubscriptionMessage(RequestMessage):
    clk: Optional[str] = Field(
        None,
        description='Token value delta (received in MarketChangeMessage) that should be passed to resume a subscription',
    )
    conflateMs: Optional[int] = Field(
        None,
        description='Conflate Milliseconds - the conflation rate (looped back on initial image after validation: bounds are 0 to 120000)',
    )
    heartbeatMs: Optional[int] = Field(
        None,
        description='Heartbeat Milliseconds - the heartbeat rate (looped back on initial image after validation: bounds are 500 to 5000)',
    )
    initialClk: Optional[str] = Field(
        None,
        description='Token value (received in initial MarketChangeMessage) that should be passed to resume a subscription',
    )
    orderFilter: Optional[OrderFilter] = None
    segmentationEnabled: Optional[bool] = Field(
        None,
        description='Segmentation Enabled - allow the server to send large sets of data in segments, instead of a single block',
    )


class AllRequestTypesExample(BaseModel):
    authentication: Optional[AuthenticationMessage] = None
    heartbeat: Optional[HeartbeatMessage] = None
    marketSubscription: Optional[MarketSubscriptionMessage] = None
    opTypes: Optional[OpTypes] = None
    orderSubscriptionMessage: Optional[OrderSubscriptionMessage] = None


class MarketChange(BaseModel):
    con: Optional[bool] = Field(
        None,
        description='Conflated - have more than a single change been combined (or null if not conflated)',
    )
    id: Optional[str] = Field(None, description='Market Id - the id of the market')
    img: Optional[bool] = Field(
        None,
        description='Image - replace existing prices / data with the data supplied: it is not a delta (or null if delta)',
    )
    marketDefinition: Optional[MarketDefinition] = None
    rc: Optional[List[RunnerChange]] = Field(
        None,
        description='Runner Changes - a list of changes to runners (or null if un-changed)',
    )
    tv: Optional[float] = Field(
        None,
        description='The total amount matched across the market. This value is truncated at 2dp (or null if un-changed)',
    )


class MarketChangeMessage(ResponseMessage):
    clk: Optional[str] = Field(
        None,
        description='Token value (non-null) should be stored and passed in a MarketSubscriptionMessage to resume subscription (in case of disconnect)',
    )
    conflateMs: Optional[int] = Field(
        None,
        description='Conflate Milliseconds - the conflation rate (may differ from that requested if subscription is delayed)',
    )
    ct: Optional[Ct] = Field(
        None,
        description='Change Type - set to indicate the type of change - if null this is a delta)',
    )
    heartbeatMs: Optional[int] = Field(
        None,
        description='Heartbeat Milliseconds - the heartbeat rate (may differ from requested: bounds are 500 to 30000)',
    )
    initialClk: Optional[str] = Field(
        None,
        description='Token value (non-null) should be stored and passed in a MarketSubscriptionMessage to resume subscription (in case of disconnect)',
    )
    mc: Optional[List[MarketChange]] = Field(
        None,
        description='MarketChanges - the modifications to markets (will be null on a heartbeat',
    )
    pt: Optional[int] = Field(
        None,
        description='Publish Time (in millis since epoch) that the changes were generated',
    )
    segmentType: Optional[SegmentType] = Field(
        None,
        description='Segment Type - if the change is split into multiple segments, this denotes the beginning and end of a change, and segments in between. Will be null if data is not segmented',
    )
    status: Optional[int] = Field(
        None,
        description='Stream status: set to null if the exchange stream data is up to date and 503 if the downstream services are experiencing latencies',
    )


class OrderMarketChange(BaseModel):
    accountId: Optional[int] = None
    closed: Optional[bool] = None
    fullImage: Optional[bool] = None
    id: Optional[str] = Field(
        None, description='Market Id - the id of the market the order is on'
    )
    orc: Optional[List[OrderRunnerChange]] = Field(
        None, description='Order Changes - a list of changes to orders on a selection'
    )


class OrderChangeMessage(ResponseMessage):
    clk: Optional[str] = Field(
        None,
        description='Token value (non-null) should be stored and passed in a MarketSubscriptionMessage to resume subscription (in case of disconnect)',
    )
    conflateMs: Optional[int] = Field(
        None,
        description='Conflate Milliseconds - the conflation rate (may differ from that requested if subscription is delayed)',
    )
    ct: Optional[Ct] = Field(
        None,
        description='Change Type - set to indicate the type of change - if null this is a delta)',
    )
    heartbeatMs: Optional[int] = Field(
        None,
        description='Heartbeat Milliseconds - the heartbeat rate (may differ from requested: bounds are 500 to 30000)',
    )
    initialClk: Optional[str] = Field(
        None,
        description='Token value (non-null) should be stored and passed in a MarketSubscriptionMessage to resume subscription (in case of disconnect)',
    )
    oc: Optional[List[OrderMarketChange]] = Field(
        None,
        description="OrderMarketChanges - the modifications to account's orders (will be null on a heartbeat",
    )
    pt: Optional[int] = Field(
        None,
        description='Publish Time (in millis since epoch) that the changes were generated',
    )
    segmentType: Optional[SegmentType] = Field(
        None,
        description='Segment Type - if the change is split into multiple segments, this denotes the beginning and end of a change, and segments in between. Will be null if data is not segmented',
    )
    status: Optional[int] = Field(
        None,
        description='Stream status: set to null if the exchange stream data is up to date and 503 if the downstream services are experiencing latencies',
    )


class AllResponseTypesExample(BaseModel):
    connection: Optional[ConnectionMessage] = None
    marketChangeMessage: Optional[MarketChangeMessage] = None
    opTypes: Optional[OpTypes1] = None
    orderChangeMessage: Optional[OrderChangeMessage] = None
    status: Optional[StatusMessage] = None
